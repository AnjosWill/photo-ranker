# Feature 4.2 ‚Äî Elo Logic

> **Objetivo:** Implementar sistema de ranking Elo para confrontos entre fotos.

---

## üéØ Objetivo

Criar m√≥dulo dedicado para c√°lculo de Elo rating, gera√ß√£o de confrontos e gerenciamento de pontua√ß√£o.

---

## üì¶ Escopo

### In Scope:
- [x] M√≥dulo `elo.js` independente
- [x] Fun√ß√£o `calculateElo(winnerElo, loserElo, k=32)`
- [x] Fun√ß√£o `generatePairings(photos)` (confrontos balanceados)
- [x] Fun√ß√£o `updateEloScores(winnerId, loserId, eloScores)`
- [x] Testes unit√°rios (casos extremos)
- [x] Documenta√ß√£o de algoritmo

### Out of Scope:
- ‚ùå Interface de confronto (F4.3)
- ‚ùå Persist√™ncia (ser√° integrada em F4.3)

---

## üß© Requisitos Funcionais (RF)

### RF1 ‚Äî C√°lculo Elo
- **RF1.1**: Implementar f√≥rmula padr√£o Elo (FIDE)
- **RF1.2**: Rating inicial: 1500 para todas as fotos
- **RF1.3**: K-factor: 32 (padr√£o, ajust√°vel)
- **RF1.4**: Retornar novo rating de vencedor e perdedor

### RF2 ‚Äî Gera√ß√£o de Confrontos
- **RF2.1**: Gerar pares balanceados (ratings pr√≥ximos)
- **RF2.2**: Evitar repeti√ß√£o de confrontos (hist√≥rico)
- **RF2.3**: Ordenar confrontos por diferen√ßa de Elo (menor primeiro)
- **RF2.4**: Round-robin at√© definir campe√£o

### RF3 ‚Äî Gerenciamento de Scores
- **RF3.1**: Inicializar scores: `{ photoId: 1500, ... }`
- **RF3.2**: Atualizar scores ap√≥s cada confronto
- **RF3.3**: Ordenar fotos por Elo (ranking)
- **RF3.4**: Detectar campe√£o (maior Elo ap√≥s N confrontos)

---

## üé® Requisitos N√£o Funcionais (RNF)

### RNF1 ‚Äî Performance
- **RNF1.1**: C√°lculo Elo < 1ms
- **RNF1.2**: Gera√ß√£o de pairings < 10ms para 100 fotos

### RNF2 ‚Äî Testabilidade
- **RNF2.1**: Fun√ß√µes puras (sem side effects)
- **RNF2.2**: Cobertura de testes > 90%

---

## üß± Arquitetura

### Arquivo Novo:
- `public/scripts/elo.js` - M√≥dulo de Elo rating

### Estrutura do M√≥dulo:

```javascript
/**
 * elo.js
 * Sistema de ranking Elo para confrontos entre fotos
 */

/**
 * Calcula novos ratings ap√≥s um confronto
 * @param {number} winnerElo - Rating atual do vencedor
 * @param {number} loserElo - Rating atual do perdedor
 * @param {number} k - K-factor (padr√£o: 32)
 * @returns {{winner: number, loser: number}} Novos ratings
 */
export function calculateElo(winnerElo, loserElo, k = 32) {
  const expectedWinner = 1 / (1 + Math.pow(10, (loserElo - winnerElo) / 400));
  const expectedLoser = 1 - expectedWinner;
  
  const newWinnerElo = Math.round(winnerElo + k * (1 - expectedWinner));
  const newLoserElo = Math.round(loserElo + k * (0 - expectedLoser));
  
  return {
    winner: newWinnerElo,
    loser: newLoserElo
  };
}

/**
 * Inicializa scores Elo para fotos
 * @param {Array} photos - Array de fotos
 * @returns {Object} { photoId: 1500, ... }
 */
export function initializeEloScores(photos) {
  const scores = {};
  photos.forEach(p => {
    scores[p.id] = 1500; // Rating inicial
  });
  return scores;
}

/**
 * Gera pares de confronto balanceados
 * @param {Array} photos - Fotos qualificadas
 * @param {Object} eloScores - Scores atuais
 * @param {Array} history - Confrontos j√° realizados
 * @returns {Array} [{photoA, photoB}, ...]
 */
export function generatePairings(photos, eloScores, history = []) {
  // Ordenar por Elo
  const sorted = [...photos].sort((a, b) => 
    (eloScores[b.id] || 1500) - (eloScores[a.id] || 1500)
  );
  
  const pairings = [];
  const used = new Set();
  
  // Parear fotos com Elo pr√≥ximo
  for (let i = 0; i < sorted.length - 1; i++) {
    if (used.has(sorted[i].id)) continue;
    
    for (let j = i + 1; j < sorted.length; j++) {
      if (used.has(sorted[j].id)) continue;
      
      // Verificar se confronto j√° ocorreu
      const pair = [sorted[i].id, sorted[j].id].sort().join('-');
      const alreadyFaced = history.some(h => 
        [h.photoA, h.photoB].sort().join('-') === pair
      );
      
      if (!alreadyFaced) {
        pairings.push({ photoA: sorted[i], photoB: sorted[j] });
        used.add(sorted[i].id);
        used.add(sorted[j].id);
        break;
      }
    }
  }
  
  return pairings;
}

/**
 * Atualiza scores ap√≥s confronto
 * @param {string} winnerId - ID do vencedor
 * @param {string} loserId - ID do perdedor
 * @param {Object} eloScores - Scores atuais
 * @param {number} k - K-factor
 * @returns {Object} Scores atualizados
 */
export function updateEloScores(winnerId, loserId, eloScores, k = 32) {
  const winnerElo = eloScores[winnerId] || 1500;
  const loserElo = eloScores[loserId] || 1500;
  
  const newRatings = calculateElo(winnerElo, loserElo, k);
  
  return {
    ...eloScores,
    [winnerId]: newRatings.winner,
    [loserId]: newRatings.loser
  };
}

/**
 * Determina campe√£o (maior Elo)
 * @param {Object} eloScores - Scores finais
 * @returns {string} ID do campe√£o
 */
export function getChampion(eloScores) {
  let championId = null;
  let maxElo = -Infinity;
  
  for (const [photoId, elo] of Object.entries(eloScores)) {
    if (elo > maxElo) {
      maxElo = elo;
      championId = photoId;
    }
  }
  
  return championId;
}
```

---

## ‚úÖ Definition of Done

- [ ] M√≥dulo `elo.js` criado e exportado
- [ ] Fun√ß√£o `calculateElo()` testada (10+ casos)
- [ ] Fun√ß√£o `generatePairings()` testada (edge cases)
- [ ] Fun√ß√£o `updateEloScores()` testada
- [ ] Fun√ß√£o `getChampion()` testada
- [ ] Sem erros de linter
- [ ] Documenta√ß√£o inline (JSDoc)
- [ ] README atualizado (se√ß√£o "Algoritmo Elo")

---

## üîó Depend√™ncias

- **Depende de:** Nada (m√≥dulo independente)
- **Bloqueia:** F4.3 (Battle Interface)

---

**Estimativa:** 3-4 horas  
**Prioridade:** Alta  
**Complexidade:** M√©dia

